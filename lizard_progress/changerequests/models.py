# (c) Nelen & Schuurmans.  GPL licensed, see LICENSE.rst.
# -*- coding: utf-8 -*-

"""Models that handle change requests."""

# Python 3 is coming
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import absolute_import
from __future__ import division

import logging

from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from django.contrib.gis.db import models

from lizard_progress import models as pmodels

logger = logging.getLogger(__name__)

# We have a few kinds of change requests;

# Requests are actual change requests. They come in several
# types. They can be open, accepted or refused. They have a
# motivation, enough information to be effected, and comments.

# Possible requests are generated by failed uploads. If the errors in
# the upload could possibly by fixed by requests, then the failures
# generate possible requests.  They need a bit more information from
# the uploader, and then they can be turned into real requests. If all
# possible requests are turned into real requests, and they are all
# accepted, the original uploaded file is re-submitted.


class Request(models.Model):
    REQUEST_TYPE_REMOVE_CODE = 1
    REQUEST_TYPE_MOVE_LOCATION = 2
    REQUEST_TYPE_NEW_LOCATION = 3

    TYPES = {
        REQUEST_TYPE_REMOVE_CODE: "Locatiecode verwijderen",
        REQUEST_TYPE_MOVE_LOCATION: "Locatie verplaatsen",
        REQUEST_TYPE_NEW_LOCATION: "Nieuwe locatiecode"
        }

    REQUEST_STATUS_OPEN = 1
    REQUEST_STATUS_ACCEPTED = 2
    REQUEST_STATUS_REFUSED = 3
    REQUEST_STATUS_WITHDRAWN = 4
    REQUEST_STATUS_INVALID = 5

    STATUSES = {
        REQUEST_STATUS_OPEN: "Open",
        REQUEST_STATUS_ACCEPTED: "Geaccepteerd",
        REQUEST_STATUS_REFUSED: "Geweigerd",
        REQUEST_STATUS_WITHDRAWN: "Ingetrokken",
        REQUEST_STATUS_INVALID: "Ongeldig (vanwege eerder geuploade data)"
    }

    contractor = models.ForeignKey(pmodels.Contractor)
    mtype = models.ForeignKey(pmodels.AvailableMeasurementType)

    request_type = models.IntegerField(choices=sorted(TYPES.items()))
    request_status = models.IntegerField(
        choices=sorted(STATUSES.items()), default=REQUEST_STATUS_OPEN)
    creation_date = models.DateTimeField(auto_now_add=True)
    change_date = models.DateTimeField(auto_now=True)

    location_code = models.CharField(max_length=50)

    # Only used if this request is of type new location, in case an
    # optional old location will be removed.
    old_location_code = models.CharField(max_length=50, null=True, blank=True)

    # Note - a motivation is mandatory
    motivation = models.TextField()
    motivation_changed = models.DateTimeField(auto_now_add=True)

    # Seen is only used once requests are closed -- if not seen yet,
    # it is shown to the contractor in the recent changes list.
    seen = models.BooleanField(default=False)

    # Contains coordinates of the point. Used for new points, moved points,
    # as well as for showing points on the map.
    the_geom = models.PointField(null=True, srid=pmodels.SRID)

    class Meta:
        ordering = ('creation_date',)

    def __unicode__(self):
        return (
            "{requesttype}: {codes} door {contractor} ({status})".format(
                requesttype=self.type_description,
                codes=(self.location_code +
                       (", " + self.old_location_code
                        if self.location_code else "")),
                contractor=self.contractor,
                status=self.status_description))

    @property
    def type_description(self):
        return Request.TYPES.get(self.request_type, "Onbekend")

    @property
    def status_description(self):
        return Request.STATUSES.get(self.request_status, "Onbekend")

    @property
    def is_open(self):
        return self.request_status == Request.REQUEST_STATUS_OPEN

    @property
    def is_accepted(self):
        return self.request_status == Request.REQUEST_STATUS_ACCEPTED

    @property
    def is_refused(self):
        return self.request_status == Request.REQUEST_STATUS_REFUSED

    @property
    def is_invalid(self):
        return self.request_status == Request.REQUEST_STATUS_INVALID

    def did_last_action(self, organization=None):
        """Did this organization do the last action related to this request?
        Then we don't have to show an alert to them.

        There are a few actions: comments, opening the request,
        closing the request, changing the motivation. In case of
        closing, invalid was caused elsewhere so we return False;
        withdrawing is done by the contractor, otherwise closing is
        done by the project owner. Comments are done by a specific
        organization. They have to be compared with the last change of
        the motivation. Opening also involves setting a motivation.

        If organization is None, use self.view.organization (view is set by
        the view's open_requests method)."""

        if organization is None:
            organization = self.view.organization

        if not self.is_open:
            if self.request_status == Request.REQUEST_STATUS_INVALID:
                return False  # Invalid was caused elsewhere
            elif self.request_status in (
                Request.REQUEST_STATUS_ACCEPTED,
                Request.REQUEST_STATUS_REFUSED):
                return organization == self.contractor.project.organization
            elif self.request_status == Request.REQUEST_STATUS_WITHDRAWN:
                return organization == self.contractor.organization

        # Laatste comment
        comments = list(self.requestcomment_set.all())
        comment = comments[-1]

        profile = pmodels.UserProfile.get_by_user(comment.user)
        return profile.organization == organization

    @classmethod
    def open_requests(cls):
        return cls.objects.filter(
            request_status=Request.REQUEST_STATUS_OPEN).select_related()

    @classmethod
    def closed_requests(cls):
        return cls.objects.exclude(
            request_status=Request.REQUEST_STATUS_OPEN).select_related()

    def can_see(self, profile):
        """Return True if profile is allowed to see this request."""
        if (profile.has_role(pmodels.UserRole.ROLE_MANAGER) and
            self.contractor.project.organization == profile.organization):
            return True

        if profile.has_role(pmodels.UserRole.ROLE_UPLOADER):
            return self.contractor.organization == profile.organization

        return False

    @classmethod
    def open_requests_for_profile(cls, project, profile):
        return [
            request for request in
            cls.open_requests().filter(contractor__project=project)
            if request.can_see(profile)]

    def detail_url(self):
        logger.debug("In detail_url")
        try:
            url = reverse('changerequests_detail', kwargs={
                    'project_slug': self.contractor.project.slug,
                    'request_id': str(self.id)})
            logger.debug("URL is: {}".format(url))
            return url
        except Exception as e:
            logger.debug(e)

    def record_comment(self, user, comment):
        RequestComment.objects.create(
            request=self, comment=comment, user=user)


class RequestComment(models.Model):
    """Comments connected to some request."""
    request = models.ForeignKey(Request)
    user = models.ForeignKey(User)
    comment = models.TextField()
    comment_time = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ('comment_time',)

    def __unicode__(self):
        return (
            "{u}@{d}: {c}"
            .format(u=self.user, d=self.comment_time, c=self.comment))
