# (c) Nelen & Schuurmans.  GPL licensed, see LICENSE.rst.
# -*- coding: utf-8 -*-

"""Models that handle change requests."""

# Python 3 is coming
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import absolute_import
from __future__ import division

import logging

from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from django.contrib.gis.db import models

from lizard_progress import models as pmodels

logger = logging.getLogger(__name__)

# We have a few kinds of change requests;

# Requests are actual change requests. They come in several
# types. They can be open, accepted or refused. They have a
# motivation, enough information to be effected, and comments.

# Possible requests are generated by failed uploads. If the errors in
# the upload could possibly by fixed by requests, then the failures
# generate possible requests.  They need a bit more information from
# the uploader, and then they can be turned into real requests. If all
# possible requests are turned into real requests, and they are all
# accepted, the original uploaded file is re-submitted.


class Request(models.Model):
    REQUEST_TYPE_REMOVE_CODE = 1
    REQUEST_TYPE_MOVE_LOCATION = 2
    REQUEST_TYPE_NEW_LOCATION = 3

    TYPES = {
        REQUEST_TYPE_REMOVE_CODE: "Locatiecode verwijderen",
        REQUEST_TYPE_MOVE_LOCATION: "Locatie verplaatsen",
        REQUEST_TYPE_NEW_LOCATION: "Nieuwe locatiecode"
        }

    REQUEST_STATUS_OPEN = 1
    REQUEST_STATUS_ACCEPTED = 2
    REQUEST_STATUS_REFUSED = 3
    REQUEST_STATUS_WITHDRAWN = 4
    REQUEST_STATUS_INVALID = 5

    STATUSES = {
        REQUEST_STATUS_OPEN: "Open",
        REQUEST_STATUS_ACCEPTED: "Geaccepteerd",
        REQUEST_STATUS_REFUSED: "Geweigerd",
        REQUEST_STATUS_WITHDRAWN: "Ingetrokken",
        REQUEST_STATUS_INVALID: "Ongeldig"
    }

    contractor = models.ForeignKey(pmodels.Contractor)
    mtype = models.ForeignKey(pmodels.AvailableMeasurementType)

    request_type = models.IntegerField(choices=sorted(TYPES.items()))
    request_status = models.IntegerField(
        choices=sorted(STATUSES.items()), default=REQUEST_STATUS_OPEN)

    refusal_reason = models.TextField(null=True, blank=True)
    invalid_reason = models.TextField(null=True, blank=True)

    creation_date = models.DateTimeField(auto_now_add=True)
    change_date = models.DateTimeField(auto_now=True)

    location_code = models.CharField(max_length=50)

    # Only used if this request is of type new location, in case an
    # optional old location will be removed.
    old_location_code = models.CharField(max_length=50, null=True, blank=True)

    # Note - a motivation is mandatory
    motivation = models.TextField()
    motivation_changed = models.DateTimeField(auto_now_add=True)

    # Seen is only used once requests are closed -- if not seen yet,
    # it is shown to the contractor in the recent changes list.
    seen = models.BooleanField(default=False)

    # Contains coordinates of the point. Used for new points, moved points,
    # as well as for showing points on the map.
    the_geom = models.PointField(null=True, srid=pmodels.SRID)

    class Meta:
        ordering = ('creation_date',)

    def __unicode__(self):
        return (
            "{requesttype}: {codes} door {contractor} ({status})".format(
                requesttype=self.type_description,
                codes=(self.location_code +
                       (", " + self.old_location_code
                        if self.location_code else "")),
                contractor=self.contractor,
                status=self.status_description))

    @property
    def project(self):
        return self.contractor.project

    @property
    def type_description(self):
        return Request.TYPES.get(self.request_type, "Onbekend")

    @property
    def status_description(self):
        return Request.STATUSES.get(self.request_status, "Onbekend")

    @property
    def is_open(self):
        return self.request_status == Request.REQUEST_STATUS_OPEN

    @property
    def is_accepted(self):
        return self.request_status == Request.REQUEST_STATUS_ACCEPTED

    @property
    def is_refused(self):
        return self.request_status == Request.REQUEST_STATUS_REFUSED

    @property
    def is_invalid(self):
        return self.request_status == Request.REQUEST_STATUS_INVALID

    @property
    def is_valid(self):
        return not self.is_invalid

    def get_location(self, location_code=None):
        if location_code is None:
            location_code = self.location_code

        try:
            return pmodels.Location.objects.get(
                location_code=location_code,
                project=self.project)
        except pmodels.Location.DoesNotExist:
            return None

    def set_invalid(self, reason):
        self.invalid_reason = reason
        self.request_status = Request.REQUEST_STATUS_INVALID
        self.save()
        return False

    def _check_validity(self):
        """Return True if this change request is valid. Assumes request
        is open."""
        if self.request_type == Request.REQUEST_TYPE_REMOVE_CODE:
            # Location must exist, and this contractor can't have
            # measurements for it yet.
            location = self.get_location()
            if not location:
                return self.set_invalid("Locatie bestaat niet")
            if location.has_measurements(self.mtype, self.contractor):
                return self.set_invalid("Locatie heeft al metingen")

        elif self.request_type == Request.REQUEST_TYPE_MOVE_LOCATION:
            # Location must exist, and nobody can have uploaded measurements
            # for it yet
            location = self.get_location()
            if not location:
                return self.set_invalid("Locatie bestaat niet.")
            if location.has_measurements():
                return self.set_invalid("Locatie heeft al metingen.")
        elif self.request_type == Request.REQUEST_TYPE_NEW_LOCATION:
            # Location must NOT exist, and if an old_location is
            # given, it must exist and have no measurements for this
            # contractor yet.
            location = self.get_location()
            if location:
                if location.has_scheduled_measurements(
                    mtype=self.mtype, contractor=self.contractor):
                    return self.set_invalid("Locatie bestaat al.")
            old_location = self.get_location(
                location_code=self.old_location_code)
            if not old_location:
                return self.set_invalid("Oude locatie bestaat niet.")
            if old_location.has_measurements(
                mtype=self.mtype, contractor=self.contractor):
                return self.set_invalid(
                    "Er zijn al metingen op de oude locatie.")

        return True

    def check_validity(self):
        """Returns True if this change request is still valid.

        If it is not, False is returned. This can be because the
        request is already closed (accepted, refused, withdrawn or
        invalid), in which case nothing more happens.

        If it was still open, the status of this request is also
        updated to invalid and the request is saved!"""
        if self.request_status != Request.REQUEST_STATUS_OPEN:
            return False

        return self._check_validity()

    def accept(self):
        # Sanity check
        if not self.check_validity():
            return

        # Actually perform whatever this request wants
        if self.request_type == Request.REQUEST_TYPE_REMOVE_CODE:
            self.do_remove_code()
        elif self.request_type == Request.REQUEST_TYPE_MOVE_LOCATION:
            self.do_move_location()
        elif self.request_type == Request.REQUEST_TYPE_NEW_LOCATION:
            self.do_add_location()

        # Save new status
        self.request_status = Request.REQUEST_STATUS_ACCEPTED
        self.save()

    def do_remove_code(self, location_code=None):
        location = self.get_location(location_code)

        # Delete the scheduled measurements, which shouldn't have
        # measurements connected to them (then this request would
        # be invalid).
        pmodels.ScheduledMeasurement.objects.filter(
            location=location,
            measurement_type=self.mtype,
            contractor__organization=self.contractor).delete()

        if not location.has_scheduled_measurements():
            location.delete()

    def do_move_location(self):
        location = self.get_location()
        location.the_geom = self.the_geom
        location.save()

    def do_add_location(self):
        location, created = pmodels.Location.objects.get_or_create(
            location_code=self.location_code, project=self.project,
            defaults={'the_geom': self.the_geom})

        mtype, created = pmodels.MeasurementType.objects.get_or_create(
            mtype=self.mtype, project=self.project)

        pmodels.ScheduledMeasurement.objects.get_or_create(
            project=self.project, contractor=self.contractor,
            mtype=mtype)

    def refuse(self, reason):
        self.refusal_reason = reason
        self.request_status = Request.REQUEST_STATUS_REFUSED
        self.save()

    def withdraw(self):
        self.request_status = Request.REQUEST_STATUS_WITHDRAWN
        self.save()

    def did_last_action(self, organization=None):
        """Did this organization do the last action related to this request?
        Then we don't have to show an alert to them.

        There are a few actions: comments, opening the request,
        closing the request, changing the motivation. In case of
        closing, invalid was caused elsewhere so we return False;
        withdrawing is done by the contractor, otherwise closing is
        done by the project owner. Comments are done by a specific
        organization. They have to be compared with the last change of
        the motivation. Opening also involves setting a motivation.

        If organization is None, use self.view.organization (view is set by
        the view's open_requests method)."""

        if organization is None:
            organization = self.view.organization

        if not self.is_open:
            if self.request_status == Request.REQUEST_STATUS_INVALID:
                return False  # Invalid was caused elsewhere
            elif self.request_status in (
                Request.REQUEST_STATUS_ACCEPTED,
                Request.REQUEST_STATUS_REFUSED):
                return organization == self.contractor.project.organization
            elif self.request_status == Request.REQUEST_STATUS_WITHDRAWN:
                return organization == self.contractor.organization

        # Laatste comment
        comments = list(self.requestcomment_set.all())
        comment = comments[-1]

        profile = pmodels.UserProfile.get_by_user(comment.user)
        return profile.organization == organization

    @classmethod
    def open_requests(cls):
        return cls.objects.filter(
            request_status=Request.REQUEST_STATUS_OPEN).select_related()

    @classmethod
    def closed_requests(cls):
        return cls.objects.exclude(
            request_status=Request.REQUEST_STATUS_OPEN).select_related()

    def can_see(self, profile):
        """Return True if profile is allowed to see this request."""
        if (profile.has_role(pmodels.UserRole.ROLE_MANAGER) and
            self.contractor.project.organization == profile.organization):
            return True

        if profile.has_role(pmodels.UserRole.ROLE_UPLOADER):
            return self.contractor.organization == profile.organization

        return False

    @classmethod
    def open_requests_for_profile(cls, project, profile):
        return [
            request for request in
            cls.open_requests().filter(contractor__project=project)
            if request.check_validity() and request.can_see(profile)]

    @classmethod
    def closed_requests_for_profile(cls, project, profile):
        return [
            request for request in
            cls.closed_requests().filter(contractor__project=project)
            if request.can_see(profile)]

    def detail_url(self):
        url = reverse('changerequests_detail', kwargs={
                'project_slug': self.contractor.project.slug,
                'request_id': str(self.id)})
        return url

    def record_comment(self, user, comment):
        RequestComment.objects.create(
            request=self, comment=comment, user=user)


class RequestComment(models.Model):
    """Comments connected to some request."""
    request = models.ForeignKey(Request)
    user = models.ForeignKey(User)
    comment = models.TextField()
    comment_time = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ('comment_time',)

    def __unicode__(self):
        return (
            "{u}@{d}: {c}"
            .format(u=self.user, d=self.comment_time, c=self.comment))
